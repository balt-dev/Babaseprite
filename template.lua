local template_cache = {}

local function contains(list, x)
	for _, v in pairs(list) do
		if v == x then return true end
	end
	return false
end

function createtile(width, height, tile, kind)
    local key = width .. "," .. height .. "," .. tile .. "," .. kind
    if template_cache[key] then
        return template_cache[key]
    end
    local im = Image(width, height, ColorMode.RGB)
    local frame = tile % 32
    local walk, direction = frame % 8, frame // 8
    if walk == 7 then
        walk = -1
        direction = (direction + 1) % 4
    end
    for y = 0, height - 1 do
        for x = 0, width - 1 do
            local px, py = x, y
            if kind == -1 then
                -- Draw a circle using im:drawPixel(x, y, color)
                local dx, dy = x - width / 2, y - height / 2
                if dx * dx + dy * dy < width * height / 4 then
                    im:drawPixel(x, y,  Color(255, 255, 255, 255))
                end
            elseif kind == 0 then
                -- Draw an arrow, then turn it to the correct direction
                if direction % 2 == 1 then
                    -- Rotate 90 degrees and squash to fit
                    px, py = (py / height) * width, (px / width) * height
                end
                if direction == 2 then
                    px = width - px - 1
                end
                if direction == 1 then
                    py = height - py - 1
                end
                -- Draw arrow stem
                if x < width / 2 and math.abs(y - height / 2) <= height / 6 then
                    im:drawPixel(px, py,  Color(255, 255, 255, 255))
                end
                -- Draw arrow head
                if x >= width / 2 and math.abs(y - height / 2) <= height - (x * (height / width)) then
                    im:drawPixel(px, py,  Color(255, 255, 255, 255))
                end
            elseif kind == 1 then
                -- This is a tiling tile, meaning it can connect on any side including diagonals
                local tile_groups = { -- Unordered because they were generated by a script
                    -- Cardinal directions
                    l = {6, 28, 5, 15, 7, 21, 17, 42, 26, 33, 22, 23, 46, 41, 45, 25, 44, 31, 43, 40, 39, 36, 30, 32, 29, 27, 37, 20, 19, 4, 13, 12, 14, 24},
                    r = {13, 21, 19, 46, 43, 24, 36, 3, 16, 5, 39, 1, 11, 35, 45, 7, 40, 42, 32, 44, 9, 38, 37, 34, 33, 17, 18, 41, 30, 29, 27, 25, 23, 15},
                    u = {18, 10, 24, 6, 25, 22, 35, 43, 37, 32, 21, 23, 46, 15, 45, 41, 44, 38, 2, 17, 29, 39, 19, 31, 33, 7, 28, 16, 30, 20, 40, 3, 11, 14},
                    d = {27, 39, 8, 28, 41, 33, 19, 23, 38, 18, 14, 46, 13, 45, 32, 43, 15, 42, 10, 29, 40, 9, 37, 44, 35, 30, 34, 36, 31, 26, 25, 22, 11, 12},
                    -- Orthogonal corners, clockwise, denoted by their position on the keyboard
                    q = {45, 22, 25, 32, 46, 21, 20, 23, 40, 33, 31, 41, 24},
                    e = {24, 44, 16, 17, 46, 39, 38, 33, 41, 30, 25, 19, 18},
                    c = {40, 43, 34, 37, 41, 36, 39, 46, 38, 44, 45, 35, 42},
                    z = {33, 43, 42, 28, 46, 45, 27, 44, 32, 30, 31, 29, 26}                                                                                                                                                                                                                     
                }
                -- Draw a square in the center
                if x >= width / 4 and x < width * 3 / 4 and y >= height / 4 and y < height * 3 / 4 then
                    im:drawPixel(x, y,  Color(255, 255, 255, 255))
                end
                -- thank you copilot ^^ (i did check this code, it's correct)
                if contains(tile_groups.l, tile) and x < width / 4 and y >= height / 4 and y < height * 3 / 4 then im:drawPixel(x, y,  Color(255, 255, 255, 255)) end
                if contains(tile_groups.r, tile) and x >= width * 3 / 4 and y >= height / 4 and y < height * 3 / 4 then im:drawPixel(x, y,  Color(255, 255, 255, 255)) end
                if contains(tile_groups.u, tile) and y < height / 4 and x >= width / 4 and x < width * 3 / 4 then im:drawPixel(x, y,  Color(255, 255, 255, 255)) end
                if contains(tile_groups.d, tile) and y >= height * 3 / 4 and x >= width / 4 and x < width * 3 / 4 then im:drawPixel(x, y,  Color(255, 255, 255, 255)) end
                if contains(tile_groups.q, tile) and x < width / 4 and y < height / 4 then im:drawPixel(x, y,  Color(255, 255, 255, 255)) end
                if contains(tile_groups.e, tile) and x >= width * 3 / 4 and y < height / 4 then im:drawPixel(x, y,  Color(255, 255, 255, 255)) end
                if contains(tile_groups.c, tile) and x >= width * 3 / 4 and y >= height * 3 / 4 then im:drawPixel(x, y,  Color(255, 255, 255, 255)) end
                if contains(tile_groups.z, tile) and x < width / 4 and y >= height * 3 / 4 then im:drawPixel(x, y,  Color(255, 255, 255, 255)) end
            elseif kind == 2 then
                -- Character tile
                -- 0 through 3 for walk frames, + 8 for each direction, - 1 for sleep, mod 32
                -- If walk frame is odd, shift it up a bit
                if walk % 2 == 1 then
                    py = py - 1
                end
                -- Draw a small circle for the body
                local dx, dy = x - width / 2, y - height / 2
                if dx * dx + dy * dy < width * height / 8 then
                    im:drawPixel(px, py,  Color(255, 255, 255, 255))
                end
                -- Draw eyes, dots for awake, dashes for asleep
                if (direction == 0 or direction == 2) -- Facing left/right
                    and x >= width * 1 / 2
                    and x < width * 3 / 4
                    and x % (width / 6) < width / 12
                    and (walk ~= -1 or y > height * 3 / 7)
                    and y < height * 1 / 2
                    and y > height * 2 / 5
                then
                    if direction == 2 then px = width - px end
                    im:drawPixel(px, py,  Color(255, 255, 255, 0))
                elseif direction == 3 -- Facing down
                    and y > height * 1 / 2
                    and y < height * 3 / 5
                    and ((
                        walk ~= -1
                        and (x - (width * 1/24)) % (width / 6) <= width / 12
                        and math.abs(x - width / 2) <= width / 6
                    ) or (
                        walk == -1
                        and (x - (width * 9/16)) % (width / 4) <= width / 8
                        and math.abs(x - width / 2) <= width / 4
                        and y < height * 4 / 7
                    ))
                then
                    im:drawPixel(px, py,  Color(255, 255, 255, 0))
                end  -- Facing up needs no eyes
            elseif kind == 3 then
                if direction % 2 == 1 then
                    -- Rotate 90 degrees and squash to fit
                    px, py = (py / height) * width, (px / width) * height
                end
                if direction == 2 then
                    px = width - px - 1
                end
                if direction == 1 then
                    py = height - py - 1
                end
                if
                    math.abs(y - (height / 2)) > (3 * height) / 8 or
                    (math.abs((2 * y) - height) * width) / height < (((-2 * x) + ((width * walk + 1) / 4)) % width) - (width / 2)
                then
                    im:drawPixel(px, py,  Color(255, 255, 255, 255))
                end
            else
                local nx, ny = (x / width) - 0.5, (y / height) - 0.5
                if
                    (
                        (nx * nx + ny * ny) * 4 < 1 and
                        (nx * nx + ny * ny) * 4 > 0.5 and
                        ((math.atan(ny, nx) + (walk * (15 * math.pi / 180))) * 180 / math.pi) % 60 < 30
                    ) or
                    (
                        (nx * nx + ny * ny) * 4 < 0.5 and
                        (nx * nx + ny * ny) * 4 > 0.03125
                    )
                then
                    im:drawPixel(px, py,  Color(255, 255, 255, 255))
                end
            end
        end
    end
    template_cache[key] = im
    return im
end

return createtile